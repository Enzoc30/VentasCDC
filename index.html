<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Validador CDC - JavaScript</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
</head>

<body class="bg-slate-100 min-h-screen flex items-center justify-center p-4">
    <div class="bg-white p-8 rounded-2xl shadow-2xl w-full max-w-lg border-t-4 border-green-600">
        <h1 class="text-3xl font-extrabold text-slate-800 mb-2">Validador CDC (JS)</h1>
        <p class="text-slate-500 mb-8 text-sm">Versi칩n ultra r치pida en JavaScript. Los datos no salen de tu navegador.
        </p>

        <div class="space-y-6">
            <div
                class="group relative border-2 border-dashed border-slate-300 rounded-xl p-8 transition-all hover:border-green-400 text-center">
                <input type="file" id="file-upload" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                    accept=".xlsx">
                <div id="upload-label">
                    <p class="text-slate-600 font-medium text-lg">游늬 Selecciona tu archivo Excel</p>
                    <p class="text-slate-400 text-xs mt-1">Se procesar치 localmente al instante</p>
                </div>
            </div>

            <div id="status"
                class="hidden text-center py-2 px-4 bg-blue-50 text-blue-700 rounded-lg text-sm font-semibold animate-pulse">
                Procesando correlativos...
            </div>

            <div id="result-area" class="hidden">
                <button id="download-btn"
                    class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-4 rounded-xl transition-all shadow-lg">
                    Descargar Reporte de Observaciones
                </button>
            </div>
        </div>
    </div>

    <script>
        const fileInput = document.getElementById('file-upload');
        const status = document.getElementById('status');
        const resultArea = document.getElementById('result-area');
        const downloadBtn = document.getElementById('download-btn');
        let processedWorkbook = null;

        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            status.classList.remove('hidden');
            resultArea.classList.add('hidden');

            const reader = new FileReader();
            reader.onload = (event) => {
                const data = new Uint8Array(event.target.result);
                const workbook = XLSX.read(data, { type: 'array' });

                // 1. Obtener la primera hoja y convertir a JSON
                const firstSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[firstSheetName];

                // Empezamos desde la fila 11 (header=10 en python es index 10 aqu칤)
                const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, range: 10 });

                const nombresDoc = { "01": "FACTURA", "03": "BOLETA DE VENTA", "07": "NOTA DE CR칄DITO" };
                const observaciones = [];
                const completos = [];

                // 2. Agrupar datos por Tipo (Col D / Index 3) y Serie (Col E / Index 4)
                // Filtrar solo tipos que empiecen con "0"
                const rawRows = jsonData.filter(row => row[3] && String(row[3]).match(/^0\d+$/));

                const groupedData = {};
                rawRows.forEach(row => {
                    const tipo = String(row[3]);
                    const serie = String(row[4]);
                    const num = parseInt(row[5]);

                    if (!isNaN(num)) {
                        if (!groupedData[tipo]) groupedData[tipo] = {};
                        if (!groupedData[tipo][serie]) groupedData[tipo][serie] = [];
                        groupedData[tipo][serie].push(num);
                    }
                });

                // 3. L칩gica de validaci칩n
                Object.keys(groupedData).sort().forEach(tipo => {
                    const descTipo = nombresDoc[tipo] || "OTRO";
                    const seriesObj = groupedData[tipo];
                    const seriesExistentes = Object.keys(seriesObj).sort();

                    // Validar saltos de SERIES
                    if (seriesExistentes.length > 0) {
                        const firstSerie = seriesExistentes[0];
                        const prefijo = firstSerie.match(/^[A-Z]+/)?.[0] || "";
                        const numsSeries = seriesExistentes.map(s => parseInt(s.replace(/^[A-Z]+/, "")));

                        const minS = Math.min(...numsSeries);
                        const maxS = Math.max(...numsSeries);

                        for (let i = minS; i <= maxS; i++) {
                            const serieTeorica = prefijo + String(i).padStart(2, '0');
                            if (!seriesExistentes.includes(serieTeorica)) {
                                observaciones.push(["SERIE", tipo, descTipo, "Falta serie completa", serieTeorica, "N/A"]);
                            }
                        }
                    }

                    // Validar saltos de CORRELATIVOS
                    seriesExistentes.forEach(serie => {
                        const nums = seriesObj[serie].sort((a, b) => a - b);
                        const minN = nums[0];
                        const maxN = nums[nums.length - 1];
                        const numSet = new Set(nums);

                        let tieneFaltantes = false;
                        for (let n = minN; n <= maxN; n++) {
                            if (!numSet.has(n)) {
                                observaciones.push(["N칔MERO", tipo, descTipo, "Falta correlativo", serie, n]);
                                tieneFaltantes = true;
                            }
                        }

                        if (!tieneFaltantes) {
                            completos.push([tipo, descTipo, serie, `${minN} al ${maxN}`]);
                        }
                    });
                });

                // 4. Crear la nueva hoja de OBSERVACIONES
                const wsObs = XLSX.utils.aoa_to_sheet([
                    ["NIVEL", "TIPO", "DESCRIPCION", "DETALLE", "SERIE", "NUMERO"]
                ]);

                // Agregar datos de observaciones
                XLSX.utils.sheet_add_aoa(wsObs, observaciones, { origin: "A2" });

                // Agregar datos de completas en Columna H (8va col) Fila 4
                XLSX.utils.sheet_add_aoa(wsObs, [["TIPO_OK", "DOC_OK", "SERIE_COMPLETA", "RANGO"]], { origin: "H4" });
                XLSX.utils.sheet_add_aoa(wsObs, completos, { origin: "H5" });

                // 5. A침adir al workbook original
                if (workbook.SheetNames.includes("OBSERVACIONES")) {
                    delete workbook.Sheets["OBSERVACIONES"];
                    workbook.SheetNames = workbook.SheetNames.filter(n => n !== "OBSERVACIONES");
                }
                XLSX.utils.book_append_sheet(workbook, wsObs, "OBSERVACIONES");

                processedWorkbook = workbook;
                status.classList.add('hidden');
                resultArea.classList.remove('hidden');
            };
            reader.readAsArrayBuffer(file);
        });

        downloadBtn.addEventListener('click', () => {
            if (processedWorkbook) {
                XLSX.writeFile(processedWorkbook, "Reporte_Analizado_CDC.xlsx");
            }
        });
    </script>
</body>

</html>